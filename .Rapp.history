5 plot_taxa_bar#
# Subset further to top 5 phyla#
top5ph <- sort(tapply(speciesSums(GP), taxTab(GP)[, "Phylum"], sum), decreasing=TRUE)[1:5]#
GP1     <- subset_species(GP, Phylum %in% names(top5ph))#
(p5 <- plot_taxa_bar(GP1, "Phylum", NULL, threshold=0.9, "human", "SampleType", #
							facet_formula= TaxaGroup ~ .) )
Load packages#
####################################################
library("phyloseq"); library("ggplot2"); library("scales"); library("grid")#
#
####################################################
# Examples for looking at package-level documentation#
####################################################
?"phyloseq-package"#
?phyloseq # this is a function#
#
####################################################
### code chunk number 9: phyloseq_basics.Rnw:234-236#
####################################################
  data(GlobalPatterns)#
  GlobalPatterns#
####################################################
### code chunk number 4: phyloseq_analysis.Rnw:103-109#
####################################################
# prune OTUs that are not present in at least one sample#
GP <- prune_species(speciesSums(GlobalPatterns) > 0, GlobalPatterns)#
# Define a human-associated versus non-human categorical variable:#
human <- getVariable(GP, "SampleType") %in% c("Feces", "Mock", "Skin", "Tongue")#
# Add new human variable to sample data:#
sampleData(GP)$human <- factor(human)#
# Some examples for plotting richness estimates from un-trimmed data.#
####################################################
### code chunk number 5: phyloseq_analysis.Rnw:121-124#
####################################################
p <- plot_richness_estimates(GP, "human", "SampleType")#
(p <- p + geom_boxplot(data=p$data, aes(x=human, y=value, color=NULL), alpha=0.1))#
print(p)#
p#
####################################################
### code chunk number 6: phyloseq_analysis.Rnw:126-127#
####################################################
# ggsave("phyloseq_analysis-richness_estimates.pdf", p, width=11, height=7) # If you wanted to save a pdf of the graphic#
####################################################
####################################################
# Filtering example code#
####################################################
####################################################
#
# # # # # prune_species() VERSUS subset_species()#
####################################################
### code chunk number 14: phyloseq_basics.Rnw:360-363#
####################################################
topN <- 20#
most_abundant_taxa <- sort(speciesSums(GP), TRUE)[1:topN]#
print(most_abundant_taxa)#
ex2 <- prune_species(names(most_abundant_taxa), GP)#
# Exploratory tree #1 (Note, too ma)#
(p <- plot_tree(ex2, color="SampleType", label.tips="Family", size="abundance"))#
#
# # # # # That was prune_species(), when we know the OTU-IDs of the ones we want, or a logical from a test#
# # # # # Alternatively, you can subset based on taxonomic rank, using subset_species() and an expression.#
####################################################
### code chunk number 7: phyloseq_analysis.Rnw:144-145#
####################################################
GP.chl <- subset_species(GP, Phylum=="Chlamydiae")#
# Exploratory tree #2#
(p <- plot_tree(GP.chl, color="SampleType", shape="Family", label.tips="Genus", size="abundance"))#
# # # # # Use filterfunSample() and genefilterSample()#
####################################################
### code chunk number 17: phyloseq_basics.Rnw:391-396#
####################################################
f1  <- filterfunSample(topp(0.1))#
print(f1)#
wh1 <- genefilterSample(GP, f1, A=round(0.5*nsamples(GP)))#
sum(wh1)#
ex2 <- prune_species(wh1, GP)#
# # # # # Variance-based filtering#
####################################################
# Subset just the Crenarchaeota from all samples:#
####################################################
gpac <- subset_species(GP, Phylum=="Crenarchaeota")#
##
##
specvar <- sapply(species.names(gpac), function(i, physeq){#
	var(getSamples(physeq, i))#
}, gpac)#
p1 <- qplot(x=log10(variance), data=data.frame(variance=specvar),#
		binwidth=abs(do.call("-", as.list(range(log10(specvar))))/20)#
		)#
# # # # # But:		#
# # # # # The value of the variance is highly-dependent on the sequencing effort#
# # # # # of each sample#
# # # # # (the total number ofreads sequenced from a particular sample)#
# # # # # Segway to transformations (e.g. fractional abundance prior to filtering)#
####################################################
####################################################
# Transformations#
# Useful for:#
# Standardization / Normalization / Smoothing / Shrinking#
####################################################
####################################################
# # # # # second-order function:#
# # # # # transformSampleCounts()#
# Should normalize to sample fraction before estimating variance for filtering.#
gpacf   <- transformSampleCounts(gpac, function(x){x/sum(x)})#
specvar <- sapply(species.names(gpacf), function(i, physeq){var(getSamples(physeq, i))}, gpacf)#
qplot(x=log10(variance), data=data.frame(variance=specvar))#
#
p2 <- qplot(x=log10(variance), data=data.frame(variance=specvar),#
	binwidth=abs(do.call("-", as.list(range(log10(specvar))))/20)#
	)#
grid.newpage()#
pushViewport(viewport(layout = grid.layout(2, 1)))#
print(p1, vp=viewport(layout.pos.row = 1, layout.pos.col = 1))#
print(p2, vp=viewport(layout.pos.row = 2, layout.pos.col = 1))#
#
# # # # # That's interesting. #
# # # # # Now how would we filter the taxa with variance smaller than 0.001?#
gpac_filt <- prune_species(specvar > 0.001, gpac)#
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family")#
##
# # # # # Note that this is not an endorsement of this particular threshold (0.001)#
# # # # # Just a demonstration#
##
# # # # # For normalization, Susan says to look at the edgeR package.#
##
# # # # # Also for standardization, decostand() function in vegan-package#
#
####################################################
####################################################
# Graphical Exploration of data#
##
####################################################
####################################################
# plot_heatmap transformations.#
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family", trans=identity_trans())#
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family", trans=boxcox_trans(0.15))
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family", trans=log_trans(10))
Load packages#
####################################################
library("phyloseq"); library("ggplot2"); library("scales"); library("grid")#
#
####################################################
# Examples for looking at package-level documentation#
####################################################
?"phyloseq-package"#
?phyloseq # this is a function#
#
####################################################
### code chunk number 9: phyloseq_basics.Rnw:234-236#
####################################################
  data(GlobalPatterns)#
  GlobalPatterns#
####################################################
### code chunk number 4: phyloseq_analysis.Rnw:103-109#
####################################################
# prune OTUs that are not present in at least one sample#
GP <- prune_species(speciesSums(GlobalPatterns) > 0, GlobalPatterns)#
# Define a human-associated versus non-human categorical variable:#
human <- getVariable(GP, "SampleType") %in% c("Feces", "Mock", "Skin", "Tongue")#
# Add new human variable to sample data:#
sampleData(GP)$human <- factor(human)#
# Some examples for plotting richness estimates from un-trimmed data.#
####################################################
### code chunk number 5: phyloseq_analysis.Rnw:121-124#
####################################################
p <- plot_richness_estimates(GP, "human", "SampleType")#
(p <- p + geom_boxplot(data=p$data, aes(x=human, y=value, color=NULL), alpha=0.1))#
print(p)#
p#
####################################################
### code chunk number 6: phyloseq_analysis.Rnw:126-127#
####################################################
# ggsave("phyloseq_analysis-richness_estimates.pdf", p, width=11, height=7) # If you wanted to save a pdf of the graphic#
####################################################
####################################################
# Filtering example code#
####################################################
####################################################
#
# # # # # prune_species() VERSUS subset_species()#
####################################################
### code chunk number 14: phyloseq_basics.Rnw:360-363#
####################################################
topN <- 20#
most_abundant_taxa <- sort(speciesSums(GP), TRUE)[1:topN]#
print(most_abundant_taxa)#
ex2 <- prune_species(names(most_abundant_taxa), GP)#
# Exploratory tree #1 (Note, too ma)#
(p <- plot_tree(ex2, color="SampleType", label.tips="Family", size="abundance"))#
#
# # # # # That was prune_species(), when we know the OTU-IDs of the ones we want, or a logical from a test#
# # # # # Alternatively, you can subset based on taxonomic rank, using subset_species() and an expression.#
####################################################
### code chunk number 7: phyloseq_analysis.Rnw:144-145#
####################################################
GP.chl <- subset_species(GP, Phylum=="Chlamydiae")#
# Exploratory tree #2#
(p <- plot_tree(GP.chl, color="SampleType", shape="Family", label.tips="Genus", size="abundance"))#
# # # # # Use filterfunSample() and genefilterSample()#
####################################################
### code chunk number 17: phyloseq_basics.Rnw:391-396#
####################################################
f1  <- filterfunSample(topp(0.1))#
print(f1)#
wh1 <- genefilterSample(GP, f1, A=round(0.5*nsamples(GP)))#
sum(wh1)#
ex2 <- prune_species(wh1, GP)#
# # # # # Variance-based filtering#
####################################################
# Subset just the Crenarchaeota from all samples:#
####################################################
gpac <- subset_species(GP, Phylum=="Crenarchaeota")#
##
##
specvar <- sapply(species.names(gpac), function(i, physeq){#
	var(getSamples(physeq, i))#
}, gpac)#
p1 <- qplot(x=log10(variance), data=data.frame(variance=specvar),#
		binwidth=abs(do.call("-", as.list(range(log10(specvar))))/20)#
		)#
# # # # # But:		#
# # # # # The value of the variance is highly-dependent on the sequencing effort#
# # # # # of each sample#
# # # # # (the total number ofreads sequenced from a particular sample)#
# # # # # Segway to transformations (e.g. fractional abundance prior to filtering)#
####################################################
####################################################
# Transformations#
# Useful for:#
# Standardization / Normalization / Smoothing / Shrinking#
####################################################
####################################################
# # # # # second-order function:#
# # # # # transformSampleCounts()#
# Should normalize to sample fraction before estimating variance for filtering.#
gpacf   <- transformSampleCounts(gpac, function(x){x/sum(x)})#
specvar <- sapply(species.names(gpacf), function(i, physeq){var(getSamples(physeq, i))}, gpacf)#
qplot(x=log10(variance), data=data.frame(variance=specvar))#
#
p2 <- qplot(x=log10(variance), data=data.frame(variance=specvar),#
	binwidth=abs(do.call("-", as.list(range(log10(specvar))))/20)#
	)#
grid.newpage()#
pushViewport(viewport(layout = grid.layout(2, 1)))#
print(p1, vp=viewport(layout.pos.row = 1, layout.pos.col = 1))#
print(p2, vp=viewport(layout.pos.row = 2, layout.pos.col = 1))#
#
# # # # # That's interesting. #
# # # # # Now how would we filter the taxa with variance smaller than 0.001?#
gpac_filt <- prune_species(specvar > 0.001, gpac)#
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family")#
##
# # # # # Note that this is not an endorsement of this particular threshold (0.001)#
# # # # # Just a demonstration#
##
# # # # # For normalization, Susan says to look at the edgeR package.#
##
# # # # # Also for standardization, decostand() function in vegan-package#
#
####################################################
####################################################
# Graphical Exploration of data#
##
####################################################
####################################################
# plot_heatmap transformations.#
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family", trans=identity_trans())#
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family", trans=log_trans(10))#
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family", trans=boxcox_trans(0.15))
?phyloseq
plot_taxa_bar(GP1, "Phylum", NULL, threshold=0.9, "human", "SampleType")
Subset further to top 5 phyla#
top5ph <- sort(tapply(speciesSums(GP), taxTab(GP)[, "Phylum"], sum), decreasing=TRUE)[1:5]#
GP1    <- subset_species(GP, Phylum %in% names(top5ph))
plot_taxa_bar(GP1, "Phylum", NULL, threshold=0.9, "human", "SampleType")
plot_taxa_bar(GP1, "Phylum", NULL, threshold=0.9, "human", "SampleType", #
							facet_formula= TaxaGroup ~ .)
?distance
data(esophagus)#
distance(esophagus) # Unweighted UniFrac#
distance(esophagus, weighted=TRUE) # weighted UniFrac#
distance(esophagus, "jaccard") # vegdist jaccard#
distance(esophagus, "bray")    # vegdist bray-curtis#
distance(esophagus, "gower")   # vegdist option "gower"#
distance(esophagus, "g") # designdist method option "g"#
distance(esophagus, "minkowski") # invokes a method from the base dist() function.#
distance(esophagus, "(A+B-2*J)/(A+B)") # designdist custom distance
distance("help")#
distance("list")#
help("distance")
data(enterotype)#
# ig <- make_sample_network(enterotype, max.dist=0.3)#
# (p  <- plot_sample_network(ig, enterotype, color="SeqTech",#
    # shape="Enterotype", line_weight=0.4, label=NULL))#
ig <- make_sample_network(GP, "bray", 0.9)#
(p3  <- plot_sample_network(ig, GP, color="SampleType", shape="human", line_weight=0.4, label=NULL))
Try enterotype example#
data(enterotype)#
ig <- make_sample_network(enterotype, max.dist=0.3)#
(p  <- plot_sample_network(ig, enterotype, color="SeqTech",#
    shape="Enterotype", line_weight=0.4, label=NULL))
GP.NMDS <- ordinate(GPUF, "NMDS", "bray") # perform NMDS on bray-curtis distance
GP.NMDS <- ordinate(GP, "NMDS", "bray") # perform NMDS on bray-curtis distance
(p1 <- plot_ordination(GP, GP.NMDS, "samples", color="SampleType") +#
  geom_line() + geom_point(size=5) )
?ordinate
GP.NMDS.UF.ord   <- ordinate(GP, "NMDS")
GP.NMDS.gower <- ordinate(GP, "NMDS", "gower")
GP1
Get the names of the most-abundant#
top.TaxaGroup <- sort(#
	tapply(speciesSums(GP), taxTab(GP)[, "Phylum"], sum, na.rm = TRUE),#
	decreasing = TRUE)#
top.TaxaGroup <- top.TaxaGroup[top.TaxaGroup > 1*10^6]#
# Now prune further, to just the most-abundant phyla#
GP2 <- subset_species(GP, Phylum %in% names(top.TaxaGroup))#
topsp <- names(sort(speciesSums(GP2), TRUE)[1:200])#
GP2   <- prune_species(topsp, GP2)#
GP.dpcoa <- ordinate(GP2, "DPCoA")#
plot_ordination(GP2, GP.dpcoa, type="taxa", color="Phylum")#
# Customize with ggplot2 layers added directly to output#
library("ggplot2")#
plot_ordination(GP2, GP.dpcoa, type="samples", color="SampleType") + geom_line() + geom_point(size=5)#
p <- plot_ordination(GP2, GP.dpcoa, type="samples", color="SampleType", shape=human)#
print(p)#
p + geom_line() + geom_point(size=5)#
plot_ordination(GP2, GP.dpcoa, type="species", color="Phylum") + geom_line() geom_point(size=5)
plot_ordination(GP2, GP.dpcoa, type="species", color="Phylum") + geom_line() + geom_point(size=5)
plot_ordination(GP2, GP.dpcoa, type="biplot", shape="Phylum", label="SampleType")
GP.dca <- ordinate(GP2, "DCA")
plot_ordination(GP2, ordinate(GP2, "DCA"), type="biplot", shape="Phylum")
plot_ordination(GP2, GP.dpcoa, type="biplot", shape="Phylum")
plot_ordination(GP2, GP.dpcoa, type="biplot", label="Phylum")
plot_ordination(GP2, GP.dpcoa, type="split", color="Phylum", label="SampleType")
plot_ordination(GP2, ordinate(GP2, "DCA"), type="split", color="Phylum", label="SampleType")
plot_ordination(GP2, GP.dpcoa, type="split", color="SampleType", shape="Phylum", label="SampleType")
plot_ordination(GP2, ordinate(GP2, "DCA"), type="split", color="SampleType",#
	shape="Phylum", label="SampleType")
plot_ordination(GP2, ordinate(GP2, "DCA"), type="split")
plot_ordination(GP2, ordinate(GP2, "DCA"), type="split", color="SampleType")
plot_ordination(GP2, ordinate(GP2, "DCA"), type="samples")
plot_ordination(GP2, ordinate(GP2, "DCA"), type="samples", color="SampleType")
plot_ordination(GP2, ordinate(GP2, "DCA"), type="species", color="Phylum") + geom_point(size=4)
plot_ordination(GP2, ordinate(GP2, "DCA"), type="samples", color="SampleType") + geom_point(size=4)
gpac_filt
plot_heatmap(GP2, "NMDS", "bray", "SampleType", "Family")
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family", trans=identity_trans())
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family", trans=log_trans(10))
plot_heatmap(GP2, "NMDS", "jaccard", "SampleType", "Family")
library("phyloseq"); library("ggplot2"); library("scales"); library("grid")
?mt
GP.fwer.table <- mt(GP2, "human")
Load packages#
####################################################
library("phyloseq"); library("ggplot2"); library("scales"); library("grid")#
#
####################################################
# Examples for looking at package-level documentation#
####################################################
?"phyloseq-package"#
?phyloseq # this is a function#
#
####################################################
### code chunk number 9: phyloseq_basics.Rnw:234-236#
####################################################
  data(GlobalPatterns)#
  GlobalPatterns#
####################################################
### code chunk number 4: phyloseq_analysis.Rnw:103-109#
####################################################
# prune OTUs that are not present in at least one sample#
GP <- prune_species(speciesSums(GlobalPatterns) > 0, GlobalPatterns)#
# Define a human-associated versus non-human categorical variable:#
human <- getVariable(GP, "SampleType") %in% c("Feces", "Mock", "Skin", "Tongue")#
# Add new human variable to sample data:#
sampleData(GP)$human <- factor(human)#
# Some examples for plotting richness estimates from un-trimmed data.#
####################################################
### code chunk number 5: phyloseq_analysis.Rnw:121-124#
####################################################
p <- plot_richness_estimates(GP, "human", "SampleType")#
(p <- p + geom_boxplot(data=p$data, aes(x=human, y=value, color=NULL), alpha=0.1))#
print(p)#
p#
####################################################
### code chunk number 6: phyloseq_analysis.Rnw:126-127#
####################################################
# ggsave("phyloseq_analysis-richness_estimates.pdf", p, width=11, height=7) # If you wanted to save a pdf of the graphic#
####################################################
####################################################
# Filtering example code#
####################################################
####################################################
#
# # # # # prune_species() VERSUS subset_species()#
####################################################
### code chunk number 14: phyloseq_basics.Rnw:360-363#
####################################################
topN <- 20#
most_abundant_taxa <- sort(speciesSums(GP), TRUE)[1:topN]#
print(most_abundant_taxa)#
ex2 <- prune_species(names(most_abundant_taxa), GP)#
# Exploratory tree #1 (Note, too ma)#
(p <- plot_tree(ex2, color="SampleType", label.tips="Family", size="abundance"))#
#
# # # # # That was prune_species(), when we know the OTU-IDs of the ones we want, or a logical from a test#
# # # # # Alternatively, you can subset based on taxonomic rank, using subset_species() and an expression.#
####################################################
### code chunk number 7: phyloseq_analysis.Rnw:144-145#
####################################################
GP.chl <- subset_species(GP, Phylum=="Chlamydiae")#
# Exploratory tree #2#
(p <- plot_tree(GP.chl, color="SampleType", shape="Family", label.tips="Genus", size="abundance"))#
# # # # # Use filterfunSample() and genefilterSample()#
####################################################
### code chunk number 17: phyloseq_basics.Rnw:391-396#
####################################################
f1  <- filterfunSample(topp(0.1))#
print(f1)#
wh1 <- genefilterSample(GP, f1, A=round(0.5*nsamples(GP)))#
sum(wh1)#
ex2 <- prune_species(wh1, GP)#
# # # # # Variance-based filtering#
####################################################
# Subset just the Crenarchaeota from all samples:#
####################################################
gpac <- subset_species(GP, Phylum=="Crenarchaeota")#
##
##
specvar <- sapply(species.names(gpac), function(i, physeq){#
	var(getSamples(physeq, i))#
}, gpac)#
p1 <- qplot(x=log10(variance), data=data.frame(variance=specvar),#
		binwidth=abs(do.call("-", as.list(range(log10(specvar))))/20)#
		)#
# # # # # But:		#
# # # # # The value of the variance is highly-dependent on the sequencing effort#
# # # # # of each sample#
# # # # # (the total number ofreads sequenced from a particular sample)#
# # # # # Segway to transformations (e.g. fractional abundance prior to filtering)#
####################################################
####################################################
# Transformations#
# Useful for:#
# Standardization / Normalization / Smoothing / Shrinking#
####################################################
####################################################
# # # # # second-order function:#
# # # # # transformSampleCounts()#
# Should normalize to sample fraction before estimating variance for filtering.#
gpacf   <- transformSampleCounts(gpac, function(x){x/sum(x)})#
specvar <- sapply(species.names(gpacf), function(i, physeq){var(getSamples(physeq, i))}, gpacf)#
qplot(x=log10(variance), data=data.frame(variance=specvar))#
#
p2 <- qplot(x=log10(variance), data=data.frame(variance=specvar),#
	binwidth=abs(do.call("-", as.list(range(log10(specvar))))/20)#
	)#
grid.newpage()#
pushViewport(viewport(layout = grid.layout(2, 1)))#
print(p1, vp=viewport(layout.pos.row = 1, layout.pos.col = 1))#
print(p2, vp=viewport(layout.pos.row = 2, layout.pos.col = 1))#
#
# # # # # That's interesting. #
# # # # # Now how would we filter the taxa with variance smaller than 0.001?#
gpac_filt <- prune_species(specvar > 0.001, gpac)#
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family")#
##
# # # # # Note that this is not an endorsement of this particular threshold (0.001)#
# # # # # Just a demonstration#
##
# # # # # For normalization, Susan says to look at the edgeR package.#
##
# # # # # Also for standardization, decostand() function in vegan-package#
#
####################################################
####################################################
# Graphical Exploration of data#
##
####################################################
####################################################
#
# # # # # Abundance values graphical inspection ("ground-truthing")#
####################################################
# plot_taxa_bar#
####################################################
# Subset further to top 5 phyla#
top5ph <- sort(tapply(speciesSums(GP), taxTab(GP)[, "Phylum"], sum), decreasing=TRUE)[1:5]#
GP1    <- subset_species(GP, Phylum %in% names(top5ph))#
plot_taxa_bar(GP1, "Phylum", NULL, threshold=0.9, "human", "SampleType") #
plot_taxa_bar(GP1, "Phylum", NULL, threshold=0.9, "human", "SampleType", #
							facet_formula= TaxaGroup ~ .) #
####################################################
# distance function#
####################################################
?distance#
data(esophagus)#
distance(esophagus) # Unweighted UniFrac#
distance(esophagus, weighted=TRUE) # weighted UniFrac#
distance(esophagus, "jaccard") # vegdist jaccard#
distance(esophagus, "bray")    # vegdist bray-curtis#
distance(esophagus, "gower")   # vegdist option "gower"#
distance(esophagus, "g") # designdist method option "g"#
distance(esophagus, "minkowski") # invokes a method from the base dist() function.#
distance(esophagus, "(A+B-2*J)/(A+B)") # designdist custom distance#
distance("help")#
distance("list")#
help("distance") # Same as "?distance"#
# # # # # # plot_sample_network#
ig <- make_sample_network(GP, "bray", 0.9)#
(p3  <- plot_sample_network(ig, GP, color="SampleType", shape="human", line_weight=0.4, label=NULL))#
# Try enterotype example#
data(enterotype)#
ig <- make_sample_network(enterotype, max.dist=0.3)#
(p  <- plot_sample_network(ig, enterotype, color="SeqTech",#
    shape="Enterotype", line_weight=0.4, label=NULL))#
####################################################
# ordinate function#
####################################################
GP.NMDS <- ordinate(GP, "NMDS", "bray") # perform NMDS on bray-curtis distance#
# GP.NMDS.UF.ord   <- ordinate(GP, "NMDS") # UniFrac. Takes a while.#
# GP.NMDS.wUF.ord  <- ordinate(GP, "NMDS", "unifrac", weighted=TRUE) # weighted-UniFrac#
GP.NMDS.gower <- ordinate(GP, "NMDS", "gower")#
####################################################
# plot_ordination function#
####################################################
(p1 <- plot_ordination(GP, GP.NMDS, "samples", color="SampleType") +#
  geom_line() + geom_point(size=5) )#
#
?plot_ordination # Example "1-liners" are at bottom.#
# Get the names of the most-abundant#
top.TaxaGroup <- sort(#
	tapply(speciesSums(GP), taxTab(GP)[, "Phylum"], sum, na.rm = TRUE),#
	decreasing = TRUE)#
top.TaxaGroup <- top.TaxaGroup[top.TaxaGroup > 1*10^6]#
# Now prune further, to just the most-abundant phyla#
GP2 <- subset_species(GP, Phylum %in% names(top.TaxaGroup))#
topsp <- names(sort(speciesSums(GP2), TRUE)[1:200])#
GP2   <- prune_species(topsp, GP2)#
GP.dpcoa <- ordinate(GP2, "DPCoA")#
plot_ordination(GP2, GP.dpcoa, type="taxa", color="Phylum")#
# Customize with ggplot2 layers added directly to output#
library("ggplot2")#
plot_ordination(GP2, GP.dpcoa, type="samples", color="SampleType") + geom_line() + geom_point(size=5)#
p <- plot_ordination(GP2, GP.dpcoa, type="samples", color="SampleType", shape=human)#
print(p)#
p + geom_line() + geom_point(size=5)#
plot_ordination(GP2, GP.dpcoa, type="species", color="Phylum") + geom_line() + geom_point(size=5)#
plot_ordination(GP2, GP.dpcoa, type="biplot", shape="Phylum", label="SampleType")#
plot_ordination(GP2, GP.dpcoa, type="biplot", shape="Phylum")#
plot_ordination(GP2, GP.dpcoa, type="biplot", color="Phylum")#
plot_ordination(GP2, GP.dpcoa, type="biplot", label="Phylum")#
plot_ordination(GP2, GP.dpcoa, type="split", color="Phylum", label="SampleType")#
plot_ordination(GP2, GP.dpcoa, type="split", color="SampleType", shape="Phylum", label="SampleType")#
#
# # # # # dpcoa kinda ugly. Let's try DCA in one-liner syntax#
# Try one-liner#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="samples", color="SampleType") + geom_point(size=4)#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="species", color="Phylum") + geom_point(size=4)#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="split")#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="split", color="SampleType")#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="biplot", shape="Phylum")#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="split", color="Phylum", label="SampleType")#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="split", color="SampleType",#
	shape="Phylum", label="SampleType")#
# # # # # Describe NeatMap approach, then show examples.#
####################################################
# plot_heatmap function#
####################################################
plot_heatmap(GP2, "NMDS", "bray", "SampleType", "Family")#
plot_heatmap(GP2, "NMDS", "jaccard", "SampleType", "Family")#
#
# plot_heatmap transformations.#
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family", trans=log_trans(10))#
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family", trans=identity_trans())#
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family", trans=boxcox_trans(0.15))#
####################################################
# Validation#
################################################### #
# # # # # Example: through multiple testing#
#
# Calculate the multiple-inference-adjusted P-values#
GP.fwer.table <- mt(GP2, "human")#
print(head(ent.p.table, 10))#
?mt
print(head(GP.fwer.table, 10))
rownames(GP.fwer.table)
?rank.names
getTaxa(GP2, "Family")
taxTab(GP2)[rownames(GP.fwer.table), "Family"]
data.frame(GP.fwer.table, taxTab(GP2)[rownames(GP.fwer.table), "Family"])
jranks <- c("Phylum", "Family")
data.frame(GP.fwer.table, taxTab(GP2)[rownames(GP.fwer.table), jranks])
GP.fwer.table <- data.frame(GP.fwer.table, taxTab(GP2)[rownames(GP.fwer.table), jranks])
print(head(GP.fwer.table, 10))
subset(GP.fwer.table, adjp < 0.05)
jranks <- c("Phylum", "Family", "Genus")
GP.fwer.table <- data.frame(GP.fwer.table, taxTab(GP2)[rownames(GP.fwer.table), jranks])
subset(GP.fwer.table, adjp < 0.05)
Calculate the multiple-inference-adjusted P-values#
GP.fwer.table <- mt(GP2, "human")#
# getTaxa(GP2, "Family")#
jranks <- c("Phylum", "Family", "Genus")#
GP.fwer.table <- data.frame(GP.fwer.table, taxTab(GP2)[rownames(GP.fwer.table), jranks])#
subset(GP.fwer.table, adjp < 0.05)
sampleData(GP2)
What if we want FDR?#
mtm   <- mt(GP2, "human")#
# Re-order to original, and use raw p-values for adjustment via mt.rawp2adjp()#
p.mtm <- mt.rawp2adjp(mtm[order(mtm[,"index"]), "rawp"], procedure) #
# Re-order so that you can return original table#
# (ordered p-value table)#
p.adjp.ord <- p.mtm$adjp[order(p.mtm$index), ]#
# Give it the original row names from m#
rownames(p.adjp.ord) <- rownames(m)#
# Return the table of adjusted p-values for each hypothesis.#
p.adjp.ord
library("multtest")
What if we want FDR?#
library("multtest")#
mtm   <- mt(GP2, "human")#
# Re-order to original, and use raw p-values for adjustment via mt.rawp2adjp()#
p.mtm <- mt.rawp2adjp(mtm[order(mtm[,"index"]), "rawp"], procedure) #
# Re-order so that you can return original table#
# (ordered p-value table)#
p.adjp.ord <- p.mtm$adjp[order(p.mtm$index), ]#
# Give it the original row names from m#
rownames(p.adjp.ord) <- rownames(m)#
# Return the table of adjusted p-values for each hypothesis.#
p.adjp.ord
What if we want FDR?#
library("multtest")#
mtm   <- mt(GP2, "human")#
# Re-order to original, and use raw p-values for adjustment via mt.rawp2adjp()#
procedure <- c("Bonferroni", "Hochberg", "BH")#
p.mtm <- mt.rawp2adjp(mtm[order(mtm[,"index"]), "rawp"], procedure) #
# Re-order so that you can return original table#
# (ordered p-value table)#
p.adjp.ord <- p.mtm$adjp[order(p.mtm$index), ]#
# Give it the original row names from m#
rownames(p.adjp.ord) <- rownames(m)#
# Return the table of adjusted p-values for each hypothesis.#
p.adjp.ord
m
p.mtm
p.adjp.ord
rownames(p.adjp.ord) <- species.names(GP2)
p.adjp.ord
GP2.mt.table <- data.frame(p.adjp.ord, taxTab(GP2)[rownames(p.adjp.ord), jranks])
head(GP2.mt.table)
subset(GP.fwer.table, BH < 0.05)
subset(GP2.mt.table, BH < 0.05)
?sort
?order
order(GP2.mt.table[, "BH"])
GP2.mt.table[order(GP2.mt.table[, "BH"]), ]
What if we want FDR?#
library("multtest")#
mtm   <- mt(GP2, "human")#
# Re-order to original, and use raw p-values for adjustment via mt.rawp2adjp()#
procedure <- c("Bonferroni", "Hochberg", "BH")#
p.mtm <- mt.rawp2adjp(mtm[order(mtm[,"index"]), "rawp"], procedure) #
# Re-order so that you can return original table#
# (ordered p-value table)#
p.adjp.ord <- p.mtm$adjp[order(p.mtm$index), ]#
# Give it the original row names from m#
rownames(p.adjp.ord) <- species.names(GP2)#
# Return the table of adjusted p-values for each hypothesis.#
GP2.mt.table <- data.frame(p.adjp.ord, taxTab(GP2)[rownames(p.adjp.ord), jranks])#
# Re-rorder based on BH#
GP2.mt.table <- GP2.mt.table[order(GP2.mt.table[, "BH"]), ]#
subset(GP2.mt.table, BH < 0.05)
GP2
otuTable(GP2)
GP2 <- transformSampleCounts(GP2, function(x){x/sum(x)})
Calculate the multiple-inference-adjusted P-values#
GP.fwer.table <- mt(GP2, "human")#
# getTaxa(GP2, "Family")#
jranks <- c("Phylum", "Family", "Genus")#
GP.fwer.table <- data.frame(GP.fwer.table, taxTab(GP2)[rownames(GP.fwer.table), jranks])#
subset(GP.fwer.table, adjp < 0.05)
What if we want FDR?#
library("multtest")#
mtm   <- mt(GP2, "human")#
# Re-order to original, and use raw p-values for adjustment via mt.rawp2adjp()#
procedure <- c("Bonferroni", "Hochberg", "BH")#
p.mtm <- mt.rawp2adjp(mtm[order(mtm[,"index"]), "rawp"], procedure) #
# Re-order so that you can return original table#
# (ordered p-value table)#
p.adjp.ord <- p.mtm$adjp[order(p.mtm$index), ]#
# Give it the original row names from m#
rownames(p.adjp.ord) <- species.names(GP2)#
# Return the table of adjusted p-values for each hypothesis.#
GP2.mt.table <- data.frame(p.adjp.ord, taxTab(GP2)[rownames(p.adjp.ord), jranks])#
# Re-rorder based on BH#
GP2.mt.table <- GP2.mt.table[order(GP2.mt.table[, "BH"]), ]#
subset(GP2.mt.table, BH < 0.05)
Recall that GP2 <- subset_species(GP, Phylum %in% names(top.TaxaGroup))#
GP2f <- transformSampleCounts(GP2f, function(x){x/sum(x)})#
# # # # # Example: through multiple testing#
?mt#
#
# Calculate the multiple-inference-adjusted P-values#
GP.fwer.table <- mt(GP2f, "human")#
# getTaxa(GP2f, "Family")#
jranks <- c("Phylum", "Family", "Genus")#
GP.fwer.table <- data.frame(GP.fwer.table, taxTab(GP2f)[rownames(GP.fwer.table), jranks])#
subset(GP.fwer.table, adjp < 0.05)#
# # # # # What if we want FDR?#
library("multtest")#
mtm   <- mt(GP2f, "human")#
# Re-order to original, and use raw p-values for adjustment via mt.rawp2adjp()#
procedure <- c("Bonferroni", "Hochberg", "BH")#
p.mtm <- mt.rawp2adjp(mtm[order(mtm[,"index"]), "rawp"], procedure) #
# Re-order so that you can return original table#
# (ordered p-value table)#
p.adjp.ord <- p.mtm$adjp[order(p.mtm$index), ]#
# Give it the original row names from m#
rownames(p.adjp.ord) <- species.names(GP2f)#
# Return the table of adjusted p-values for each hypothesis.#
GP2f.mt.table <- data.frame(p.adjp.ord, taxTab(GP2f)[rownames(p.adjp.ord), jranks])#
# Re-rorder based on BH#
GP2f.mt.table <- GP2f.mt.table[order(GP2f.mt.table[, "BH"]), ]#
subset(GP2f.mt.table, BH < 0.05)
GP2 <- subset_species(GP, Phylum %in% names(top.TaxaGroup))
GP2
topsp <- names(sort(speciesSums(GP2), TRUE)[1:200])
GP2 <- subset_species(GP, Phylum %in% names(top.TaxaGroup))
topsp <- names(sort(speciesSums(GP2), TRUE)[1:200])
GP2   <- prune_species(topsp, GP2)
GP2f <- transformSampleCounts(GP2, function(x){x/sum(x)})
GP2f
otuTable(GP2f)
GP2f <- transformSampleCounts(GP, function(x){x/sum(x)})
GP2f
top.TaxaGroup
Validation#
####################################################
# Do testing on fractional abundance to remove #
# effect of differences in total sequencing across samples for same taxa#
# Recall that:#
# # # # GP2 <- subset_species(GP, Phylum %in% names(top.TaxaGroup))#
# # # # topsp <- names(sort(speciesSums(GP2), TRUE)[1:200])#
# # # # GP2   <- prune_species(topsp, GP2)#
topsp <- names(sort(speciesSums(GP2), TRUE)[1:500])#
GP3   <- prune_species(topsp, GP2)#
GP3f <- transformSampleCounts(GP, function(x){x/sum(x)})#
# GP3f <- subset_species(GP3f, Phylum %in% names(top.TaxaGroup))#
GP3  <- prune_species(topsp, GP3f)
GP3
otuTable(GP3)
head(otuTable(GP3))
head(otuTable(GP))
head(otuTable(GP2))
Validation#
####################################################
# Do testing on fractional abundance to remove #
# effect of differences in total sequencing across samples for same taxa#
# Recall that:#
# # # # GP2 <- subset_species(GP, Phylum %in% names(top.TaxaGroup))#
# # # # topsp <- names(sort(speciesSums(GP2), TRUE)[1:200])#
# # # # GP2   <- prune_species(topsp, GP2)#
topsp <- names(sort(speciesSums(GP2), TRUE)[1:500])#
GP3   <- prune_species(topsp, GP2)#
GP3f <- transformSampleCounts(GP, function(x){x/sum(x)})#
# GP3f <- subset_species(GP3f, Phylum %in% names(top.TaxaGroup))#
GP3  <- prune_species(topsp, GP3f)#
head(otuTable(GP))#
head(otuTable(GP2))#
head(otuTable(GP3))#
#
# # # # # Example: through multiple testing#
?mt#
#
# Calculate the multiple-inference-adjusted P-values#
GP.fwer.table <- mt(GP3f, "human")#
# getTaxa(GP3f, "Family")#
jranks <- c("Phylum", "Family", "Genus")#
GP.fwer.table <- data.frame(GP.fwer.table, taxTab(GP3f)[rownames(GP.fwer.table), jranks])#
subset(GP.fwer.table, adjp < 0.05)#
# # # # # What if we want FDR?#
library("multtest")#
mtm   <- mt(GP3f, "human")#
# Re-order to original, and use raw p-values for adjustment via mt.rawp2adjp()#
procedure <- c("Bonferroni", "Hochberg", "BH")#
p.mtm <- mt.rawp2adjp(mtm[order(mtm[,"index"]), "rawp"], procedure) #
# Re-order so that you can return original table#
# (ordered p-value table)#
p.adjp.ord <- p.mtm$adjp[order(p.mtm$index), ]#
# Give it the original row names from m#
rownames(p.adjp.ord) <- species.names(GP3f)#
# Return the table of adjusted p-values for each hypothesis.#
GP3f.mt.table <- data.frame(p.adjp.ord, taxTab(GP3f)[rownames(p.adjp.ord), jranks])#
# Re-rorder based on BH#
GP3f.mt.table <- GP3f.mt.table[order(GP3f.mt.table[, "BH"]), ]#
subset(GP3f.mt.table, BH < 0.05)
Validation#
####################################################
# Do testing on fractional abundance to remove #
# effect of differences in total sequencing across samples for same taxa#
# Recall that:#
# # # # GP2 <- subset_species(GP, Phylum %in% names(top.TaxaGroup))#
# # # # topsp <- names(sort(speciesSums(GP2), TRUE)[1:200])#
# # # # GP2   <- prune_species(topsp, GP2)#
topsp <- names(sort(speciesSums(GP), TRUE)[1:200])#
GP3f  <- transformSampleCounts(GP, function(x){x/sum(x)})#
# GP3f <- subset_species(GP3f, Phylum %in% names(top.TaxaGroup))#
GP3f  <- prune_species(topsp, GP3f)#
head(otuTable(GP))#
head(otuTable(GP2))#
head(otuTable(GP3))#
#
# # # # # Example: through multiple testing#
?mt#
#
# Calculate the multiple-inference-adjusted P-values#
GP.fwer.table <- mt(GP3f, "human")#
# getTaxa(GP3f, "Family")#
jranks <- c("Phylum", "Family", "Genus")#
GP.fwer.table <- data.frame(GP.fwer.table, taxTab(GP3f)[rownames(GP.fwer.table), jranks])#
subset(GP.fwer.table, adjp < 0.05)#
# # # # # What if we want FDR?#
library("multtest")#
mtm   <- mt(GP3f, "human")#
# Re-order to original, and use raw p-values for adjustment via mt.rawp2adjp()#
procedure <- c("Bonferroni", "Hochberg", "BH")#
p.mtm <- mt.rawp2adjp(mtm[order(mtm[,"index"]), "rawp"], procedure) #
# Re-order so that you can return original table#
# (ordered p-value table)#
p.adjp.ord <- p.mtm$adjp[order(p.mtm$index), ]#
# Give it the original row names from m#
rownames(p.adjp.ord) <- species.names(GP3f)#
# Return the table of adjusted p-values for each hypothesis.#
GP3f.mt.table <- data.frame(p.adjp.ord, taxTab(GP3f)[rownames(p.adjp.ord), jranks])#
# Re-rorder based on BH#
GP3f.mt.table <- GP3f.mt.table[order(GP3f.mt.table[, "BH"]), ]#
subset(GP3f.mt.table, BH < 0.05)
Validation#
####################################################
# Do testing on fractional abundance to remove #
# effect of differences in total sequencing across samples for same taxa#
# Recall that:#
# # # # GP2 <- subset_species(GP, Phylum %in% names(top.TaxaGroup))#
# # # # topsp <- names(sort(speciesSums(GP2), TRUE)[1:200])#
# # # # GP2   <- prune_species(topsp, GP2)#
topsp <- names(sort(speciesSums(GP), TRUE)[1:500])#
GP3f  <- transformSampleCounts(GP, function(x){x/sum(x)})#
# GP3f <- subset_species(GP3f, Phylum %in% names(top.TaxaGroup))#
GP3f  <- prune_species(topsp, GP3f)#
head(otuTable(GP))#
head(otuTable(GP2))#
head(otuTable(GP3))#
#
# # # # # Example: through multiple testing#
?mt#
#
# Calculate the multiple-inference-adjusted P-values#
GP.fwer.table <- mt(GP3f, "human")#
# getTaxa(GP3f, "Family")#
jranks <- c("Phylum", "Family", "Genus")#
GP.fwer.table <- data.frame(GP.fwer.table, taxTab(GP3f)[rownames(GP.fwer.table), jranks])#
subset(GP.fwer.table, adjp < 0.05)#
# # # # # What if we want FDR?#
library("multtest")#
mtm   <- mt(GP3f, "human")#
# Re-order to original, and use raw p-values for adjustment via mt.rawp2adjp()#
procedure <- c("Bonferroni", "Hochberg", "BH")#
p.mtm <- mt.rawp2adjp(mtm[order(mtm[,"index"]), "rawp"], procedure) #
# Re-order so that you can return original table#
# (ordered p-value table)#
p.adjp.ord <- p.mtm$adjp[order(p.mtm$index), ]#
# Give it the original row names from m#
rownames(p.adjp.ord) <- species.names(GP3f)#
# Return the table of adjusted p-values for each hypothesis.#
GP3f.mt.table <- data.frame(p.adjp.ord, taxTab(GP3f)[rownames(p.adjp.ord), jranks])#
# Re-rorder based on BH#
GP3f.mt.table <- GP3f.mt.table[order(GP3f.mt.table[, "BH"]), ]#
subset(GP3f.mt.table, BH < 0.05)
install.packages("devtools")
library("devtools")
install_github("phyloseq", "joey711")
?detach
library("phyloseq")
?"phyloseq-package"
?phyloseq
Subsection: Importing data example: Bushman et al., combined enterotypes dataset#
# Here is an example in which we download a zip file with both biom- and qiime-formatted#
# data, unzip it in a temporary directory from with in R,#
# import the relavant files using phyloseq importers, and then delete the temporary files.#
# This code *should* be platform independent, but occasionally there are finicky #
# Windows issues that arise. #
#
# The "genus and phylum" abundance tables are provided online (ftp) here:#
zipftp <- "ftp://thebeast.colorado.edu/pub/QIIME_DB_Public_Studies/study_1011_split_library_seqs_and_mapping.zip"#
# First create a temporary directory in which to store the unpacked file(s) from the .zip#
tmpdir <- tempdir()#
# Second create a temp file where you will put the .zip-file itself#
temp <- tempfile()#
# Now download the file and unzip to tmpdir directory#
download.file(zipftp, temp)#
unzip(temp, exdir = tmpdir )#
#
# Define the biom file-path#
biom_file <- file.path(tmpdir, list.files(tmpdir, pattern=".biom"))#
# Define the mapping file-path#
map_file <- file.path(tmpdir, list.files(tmpdir, pattern="mapping"))#
# Now import the .biom-formatted otuTable/taxonomyTable file.#
biom_otu_tax <- import_biom(biom_file, "greengenes")#
# Add sample data to the dataset using merge#
bmsd <- import_qiime_sampleData(map_file)#
Bushman <- merge_phyloseq(biom_otu_tax, bmsd)#
#
# Remove the temperorary file and directory where you unpacked the zip files#
unlink(temp)#
unlink(tmpdir, TRUE)
Bushman
biom_otu_tax
bmsd
Bushman <- merge_phyloseq(biom_otu_tax, bmsd)
Bushman
Section: Basic interaction with phyloseq data#
# Let's look at some basic print and accessor functions/methods provided in phyloseq#
#
# Print method#
Bushman#
#
# Convenience accessors#
nspecies(Bushman)#
nspecies(Bushman)#
sample.names(Bushman)[1:10]#
species.names(Bushman)[1:10]#
#
# Interacting with the sample variables (useful later in plotting)#
sample.variables(Bushman)[1:10]#
length(sample.variables(Bushman))#
# How can we look at the values for a particular variable#
getVariable(Bushman, sample.variables(Bushman)[5])#
#
# Interacting with the taxonomic ranks (useful later in plotting)#
rank.names(Bushman)#
getTaxa(Bushman, "ta1")#
#
# Let's assign more meaningful taxonomic rank names to Bushman#
colnames(taxTab(Bushman)) <- c(k="Kingdom", p="Phylum", c="Class", o="Order", f="Family", g="Genus", s="Species")#
getTaxa(Bushman, "Kingdom")#
getTaxa(Bushman, "Phylum")#
#
# Abundance Sums, accessors#
sampleSums(Bushman)[1:10]#
speciesSums(Bushman)[1:10]#
getSpecies(Bushman, sample.names(Bushman)[5])[1:10]#
getSamples(Bushman, species.names(Bushman)[5])[1:10]
nspecies(matrix(0, 5, 5))
matrix(0, 5, 5)
Section: simple summary graphics#
# Load additional graphics-related packages#
library("ggplot2"); library("scales"); library("grid")
plot_richness_estimates(Bushman)
(p <- plot_richness_estimates(Bushman, x="SEX"))
?plot_richness_estimates
p + geom_boxplot(data=p$data, aes(x=SEX, y=value, color=NULL), alpha=0.1)
(p <- plot_richness_estimates(Bushman, x="SEX"))
p + geom_boxplot(data=p$data, aes(x=SEX, y=value, color=NULL), alpha=0.1)
plot_richness_estimates(Bushman, x="AGE_IN_YEARS")
plot_richness_estimates(Bushman, x="INSOLUBLE_DIETARY_FIBER_G_AVE")
?geom_boxplot
data(GlobalPatterns)
GlobalPatterns
GP.chl <- subset_species(GlobalPatterns, Phylum=="Chlamydiae")
GP.chl
plot_tree(GP.chl, "treeonly")
plot_tree(GP.chl, color="SampleType", shape="Family", label.tips="Genus", size="abundance")
Subsection: Abundance bar plots for direct observation/comparison of abundances#
data(enterotype)#
TopNOTUs <- names(sort(speciesSums(enterotype), TRUE)[1:10])#
ent10   <- prune_species(TopNOTUs, enterotype)#
plot_taxa_bar(ent10, "Genus", x="SeqTech", fill="TaxaGroup")
data(GlobalPatterns)
getVariable(GP, "SampleType") %in% c("Feces", "Mock", "Skin", "Tongue")
GP <- prune_species(speciesSums(GlobalPatterns) > 0, GlobalPatterns)
getVariable(GP, "SampleType") %in% c("Feces", "Mock", "Skin", "Tongue")
Subsection: rarefy abundances to even depth#
# Although of perhaps dubious necessity, it is common for OTU abundance tables#
# to be randomly subsampled to even sequencing depth prior various analyses, especially UniFrac.#
# Here is an example comparing the UniFrac-PCoA results with and without#
# "rarefying" the abundances (Requires phyloseq v1.1.28+)#
#
# Test with esophagus dataset#
data(esophagus)#
eso <- rarefy_even_depth(esophagus)#
plot(as(otuTable(eso), "vector"), as(otuTable(esophagus), "vector"))#
UniFrac(eso); UniFrac(esophagus)#
# Test with GlobalPatterns dataset#
data(GlobalPatterns)#
GP.chl <- subset_species(GlobalPatterns, Phylum=="Chlamydiae")#
# remove the samples that have less than 20 total reads from Chlamydiae#
GP.chl <- prune_samples(names(which(sampleSums(GP.chl)>=20)), GP.chl)#
# # (p <- plot_tree(GP.chl, color="SampleType", shape="Family", label.tips="Genus", size="abundance"))#
GP.chl.r <- rarefy_even_depth(GP.chl)#
plot(as(otuTable(GP.chl.r), "vector"), as(otuTable(GP.chl), "vector"))#
# Try ordination of GP.chl and GP.chl.r (default distance is unweighted UniFrac)#
plot_ordination(GP.chl, ordinate(GP.chl, "MDS"), color="SampleType") + geom_point(size=5)#
plot_ordination(GP.chl.r, ordinate(GP.chl.r, "MDS"), color="SampleType") + geom_point(size=5)#
#
# How does rarefying affect larger datasets?#
GP.r <- rarefy_even_depth(GP)#
plot_ordination(GP, ordinate(GP), color="SampleType") + geom_point(size=5)#
plot_ordination(GP.r, ordinate(GP.r), color="SampleType") + geom_point(size=5)#
### Subsection: prune_species() VERSUS subset_species()#
# Using plot_tree to show the results, we'll try two different #
# methods for subsetting OTUs in a dataset.#
#
topN <- 20#
most_abundant_taxa <- sort(speciesSums(GP), TRUE)[1:topN]#
print(most_abundant_taxa)#
ex2 <- prune_species(names(most_abundant_taxa), GP)#
# Exploratory tree #1 (Note, too ma)#
plot_tree(ex2, color="SampleType", label.tips="Family", size="abundance")#
#
# That was prune_species(), when we know the OTU-IDs of the ones we want, or a logical from a test#
# Alternatively, you can subset based on taxonomic rank, using subset_species() and an expression.#
GP.chl <- subset_species(GP, Phylum=="Chlamydiae")#
# Exploratory tree #2#
plot_tree(GP.chl, color="SampleType", shape="Family", label.tips="Genus", size="abundance")#
### Subsection: filterfunSample() and genefilterSample()#
f1  <- filterfunSample(topp(0.1))#
print(f1)#
wh1 <- genefilterSample(GP, f1, A=round(0.5*nsamples(GP)))#
sum(wh1)#
ex2 <- prune_species(wh1, GP)#
### (Optional) Subsection: Variance-based filtering#
#
# Subset just the Crenarchaeota from all samples:#
#
gpac <- subset_species(GP, Phylum=="Crenarchaeota")#
##
##
specvar <- sapply(species.names(gpac), function(i, physeq){#
	var(getSamples(physeq, i))#
}, gpac)#
p1 <- qplot(x=log10(variance), data=data.frame(variance=specvar),#
		binwidth=abs(do.call("-", as.list(range(log10(specvar))))/20)#
		)#
#
# But:		#
# The value of the variance is highly-dependent on the sequencing effort#
# of each sample#
# (the total number of reads sequenced from a particular sample)#
# Segway to transformations (e.g. fractional abundance prior to filtering)#
## Section: Transformations#
# Useful for: Standardization / Normalization / Smoothing / Shrinking#
# second-order function: `transformSampleCounts`#
#
# Should normalize to sample fraction before estimating variance for filtering.#
gpacf   <- transformSampleCounts(gpac, function(x){x/sum(x)})#
specvar <- sapply(species.names(gpacf), function(i, physeq){var(getSamples(physeq, i))}, gpacf)#
qplot(x=log10(variance), data=data.frame(variance=specvar))#
#
p2 <- qplot(x=log10(variance), data=data.frame(variance=specvar),#
	binwidth=abs(do.call("-", as.list(range(log10(specvar))))/20)#
	)#
grid.newpage()#
pushViewport(viewport(layout = grid.layout(2, 1)))#
print(p1, vp=viewport(layout.pos.row = 1, layout.pos.col = 1))#
print(p2, vp=viewport(layout.pos.row = 2, layout.pos.col = 1))#
#
# # # # # That's interesting. #
# # # # # Now how would we filter the taxa with variance smaller than 0.001?#
gpac_filt <- prune_species(specvar > 0.001, gpac)#
plot_heatmap(gpac_filt, "NMDS", "bray", "SampleType", "Family")#
# Note that this is not an endorsement of this particular threshold (0.001)#
# Just a demonstration#
#
# For normalization, Susan says to look at the edgeR package.#
#
# Also for standardization, decostand() function in vegan-package
For sake of time, let's subset further to most abundant 5 phyla#
top5ph <- sort(tapply(speciesSums(GP), taxTab(GP)[, "Phylum"], sum), decreasing=TRUE)[1:5]#
GP1    <- subset_species(GP, Phylum %in% names(top5ph))
data(esophagus)
distance(esophagus) # Unweighted UniFrac
distance(esophagus, weighted=TRUE) # weighted UniFrac#
distance(esophagus, "jaccard") # vegdist jaccard#
distance(esophagus, "bray")    # vegdist bray-curtis#
distance(esophagus, "gower")   # vegdist option "gower"#
distance(esophagus, "g") # designdist method option "g"#
distance(esophagus, "minkowski") # invokes a method from the base dist() function.#
distance(esophagus, "(A+B-2*J)/(A+B)") # designdist custom distance#
distance("help")#
distance("list")
ig <- make_sample_network(GP, "bray", 0.9)
ig <- make_network(GP, "bray", 0.9)
ig <- make_network(GP, distance="bray", 0.9)
ig <- make_network(GP, distance="bray", max.dist=0.9)
ig <- make_network(GP, type="samples", distance="bray", max.dist=0.9)
(p3  <- plot_network(ig, GP, color="SampleType", shape="human", line_weight=0.4, label=NULL))
Define a human-associated versus non-human categorical variable:#
sampleData(GP)$human <- #
	factor(getVariable(GP, "SampleType") %in% c("Feces", "Mock", "Skin", "Tongue"))
human <- factor(getVariable(GP, "SampleType") %in% c("Feces", "Mock", "Skin", "Tongue"))
(p3  <- plot_network(ig, GP, color="SampleType", shape="human", line_weight=0.4, label=NULL))
GP.NMDS <- ordinate(GP, "NMDS", "bray") # perform NMDS on bray-curtis distance
GP.NMDS <- ordinate(GP, "MDS", "bray") # perform NMDS on bray-curtis distance
GP.MDS <- ordinate(GP, "MDS", "bray") # perform NMDS on bray-curtis distance
GP.MDS
GP.NMDS
GP.NMDS <- ordinate(GP, "NMDS", "bray") # perform NMDS on bray-curtis distance
plot_ordination(GP, GP.NMDS, "samples", color="SampleType") + geom_line() + geom_point(size=5)
Get the names of the most-abundant#
top.TaxaGroup <- sort(#
	tapply(speciesSums(GP), taxTab(GP)[, "Phylum"], sum, na.rm = TRUE),#
	decreasing = TRUE)#
top.TaxaGroup <- top.TaxaGroup[top.TaxaGroup > 1*10^6]#
# Now prune further, to just the most-abundant phyla#
GP2 <- subset_species(GP, Phylum %in% names(top.TaxaGroup))#
topsp <- names(sort(speciesSums(GP2), TRUE)[1:200])#
GP2   <- prune_species(topsp, GP2)#
GP.dpcoa <- ordinate(GP2, "DPCoA")#
plot_ordination(GP2, GP.dpcoa, type="taxa", color="Phylum")#
# Customize with ggplot2 layers added directly to output#
library("ggplot2")#
plot_ordination(GP2, GP.dpcoa, type="samples", color="SampleType") + geom_line() + geom_point(size=5)#
p <- plot_ordination(GP2, GP.dpcoa, type="samples", color="SampleType", shape=human)#
print(p)#
p + geom_line() + geom_point(size=5)#
plot_ordination(GP2, GP.dpcoa, type="species", color="Phylum") + geom_line() + geom_point(size=5)#
plot_ordination(GP2, GP.dpcoa, type="biplot", shape="Phylum", label="SampleType")#
plot_ordination(GP2, GP.dpcoa, type="biplot", shape="Phylum")#
plot_ordination(GP2, GP.dpcoa, type="biplot", color="Phylum")#
plot_ordination(GP2, GP.dpcoa, type="biplot", label="Phylum")#
plot_ordination(GP2, GP.dpcoa, type="split", color="Phylum", label="SampleType")#
plot_ordination(GP2, GP.dpcoa, type="split", color="SampleType", shape="Phylum", label="SampleType")
dpcoa kinda ugly. Let's try DCA in one-liner syntax#
# Try one-liner#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="samples", color="SampleType") + geom_point(size=4)#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="species", color="Phylum") + geom_point(size=4)#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="split")#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="split", color="SampleType")#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="biplot", shape="Phylum")#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="split", color="Phylum", label="SampleType")#
plot_ordination(GP2, ordinate(GP2, "DCA"), type="split", color="SampleType",#
	shape="Phylum", label="SampleType")
Subsection: multiple multiple testing#
# Do testing on fractional abundance to remove #
# effect of differences in total sequencing across samples for same taxa.#
# First, for the sake of time, let's subset our testing to the first 200 #
# most abundant OTUs, and transform these counts to their relative abundance#
# in their source sample.#
topsp <- names(sort(speciesSums(GP), TRUE)[1:200])#
GP3f  <- transformSampleCounts(GP, function(x){x/sum(x)})#
GP3f  <- prune_species(topsp, GP3f)#
head(otuTable(GP))#
head(otuTable(GP2))#
head(otuTable(GP3))#
#
# We are going to use the multtest wrapper included in phyloseq, `mt`.#
# Try `?mt` for help on this function.#
# To use this wrapper to calculate the multiple-inference-adjusted P-values,#
# using the "human" sample variable:#
GP.fwer.table <- mt(GP3f, "human")
GP.fwer.table
jranks <- c("Phylum", "Family", "Genus")#
GP.fwer.table <- data.frame(GP.fwer.table, taxTab(GP3f)[rownames(GP.fwer.table), jranks])#
subset(GP.fwer.table, adjp < 0.05)
Subsection: What if we want FDR instead of FWER?#
# Or to use other tools in multtest-package?#
library("multtest")#
mtm   <- mt(GP3f, "human")#
# Re-order to original, and use raw p-values for adjustment via mt.rawp2adjp()#
procedure <- c("Bonferroni", "Hochberg", "BH")#
p.mtm <- mt.rawp2adjp(mtm[order(mtm[,"index"]), "rawp"], procedure) #
# Re-order so that you can return original table#
# (ordered p-value table)#
p.adjp.ord <- p.mtm$adjp[order(p.mtm$index), ]#
# Give it the original row names from m#
rownames(p.adjp.ord) <- species.names(GP3f)#
# Return the table of adjusted p-values for each hypothesis.#
GP3f.mt.table <- data.frame(p.adjp.ord, taxTab(GP3f)[rownames(p.adjp.ord), jranks])#
# Re-rorder based on BH#
GP3f.mt.table <- GP3f.mt.table[order(GP3f.mt.table[, "BH"]), ]#
subset(GP3f.mt.table, BH < 0.05)#
# Some Alternative packages for multiple inference correction:#
# "qvalue" package, "multcomp" package
keepvariables <- which(sapply(sampleData(Bushman), is.numeric))
bushsd <- data.frame(sampleData(Bushman))[keepvariables]
bushsd
ncol(bushsd)
bioenv(veganotu(Bushman), bushsd)
library("vegan")
bioenv(veganotu(Bushman), bushsd)
keepvariables <- which(sapply(sampleData(Bushman), is.numeric))#
bushsd <- data.frame(sampleData(Bushman))[keepvariables]#
bioenv(veganotu(Bushman), bushsd)
the vegan package.#
veganotu <- function(physeq){#
	OTU <- otuTable(physeq)#
	if( speciesAreRows(OTU) ){ OTU <- t(OTU) }#
	return( as(OTU, "matrix") )#
}#
#
# Now use
keepvariables <- which(sapply(sampleData(Bushman), is.numeric))#
bushsd <- data.frame(sampleData(Bushman))[keepvariables]#
bioenv(veganotu(Bushman), bushsd)
names(bushsd)
bioenv(veganotu(Bushman) ~ DEPTH + AGE + TOTAL_FAT_G_AVE + INSOLUBLE_DIETARY_FIBER_G_AVE, bushsd)
library("cluster")#
# Load data#
data(enterotype)#
# ordination#
ent.dca <- ordinate(enterotype)
Gap Statistic: How many clusters are there?#
pam1 <- function(x,k) list(cluster = pam(x,k, cluster.only=TRUE))#
x <- scores(ent.dca)#
# gskmn <- clusGap(x[, 1:2], FUN=kmeans, nstart=20, K.max = 6, B = 500)#
gskmn <- clusGap(x[, 1:2], FUN=pam1, K.max = 6, B = 500)#
plot(gskmn, main = "Gap statistic for the 'Enterotypes' data")#
mtext("k = 2 is best ... but  k = 3  pretty close")
gskmn <- clusGap(x[, 1:2], FUN=pam1, K.max = 6, B = 100)
plot(gskmn, main = "Gap statistic for the 'Enterotypes' data")#
mtext("k = 2 is best ... but  k = 3  pretty close")
What would the wrapper-function look like?#
gap_statistic_ordination <- function(ord, FUNcluster, K.max=6, axes=c(1:2), B=500, verbose=interactive(), ...){#
	require("cluster")#
	# If "pam1" was chosen, use this internally defined call to pam#
	if(FUNcluster == "pam1"){#
		FUNcluster <- function(x,k) list(cluster = pam(x,k, cluster.only=TRUE))		#
	}#
	# Use the scores function to get the ordination coordinates#
	x <- scores(ord)#
	# If axes not explicitly defined (NULL), then use all of them#
	if(is.null(axes)){axes <- 1:ncol(x)}#
	# Finally, perform, and return, the gap statistic calculation using cluster::clusGap	#
	clusGap(x[, axes], FUN=FUNcluster, K.max=K.max, B=B, verbose=verbose, ...)#
}#
# Define a plot method for results...#
plot_clusgap <- function(clusgap, title="Gap Statistic calculation results"){#
	require("ggplot2")#
	gstab <- data.frame(gs$Tab, k=1:nrow(gs$Tab))#
	p <- ggplot(gstab, aes(k, gap)) + geom_line() + geom_point(size=5)#
	p <- p + geom_errorbar(aes(ymax=gap+SE.sim, ymin=gap-SE.sim))#
	p <- p + opts(title=title)#
	return(p)#
}#
#
# Now test the result. Should work on ordination classes recognized by `scores` function#
gs <- gap_statistic_ordination(ent.dca, "pam1", B=50, verbose=FALSE)#
print(gs, method="Tibs2001SEmax")#
plot_clusgap(gs)#
# Base graphics means of plotting.#
plot(gs, main = "Gap statistic for the 'Enterotypes' data")#
mtext("k = 2 is best ... but  k = 3  pretty close")
plot_clusgap(gs)
library("phyloseq")
